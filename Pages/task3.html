<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Задание 3</title>
    <script src="https://unpkg.com/@tailwindcss/browser@4"></script>
</head>
<body class="text-lg bg-[#eaeff7] flex flex-col min-h-screen font-mono">
    <header class="w-full p-4 bg-white text-xl relative z-[3]">
        <div class="container mx-auto flex items-center justify-between">
            <a href="../index.html" class="text-2xl font-semibold transition-all duration-500 hover:rotate-6 hover:scale-110">
                Education<span class="text-[#4b79f6]">Lab</span>
            </a>
            <div id="menu" class="flex items-center gap-6 max-md:flex-col max-md:w-full max-md:py-6 max-md:px-4 max-md:absolute max-md:bg-white max-md:top-0 max-md:left-0 max-md:border-t-2 border-[#4b79f6] transition-all duration-500 max-md:-translate-y-full">
                <a href="../index.html" class="flex flex-col after:w-0 after:h-[2px] after:rounded-full after:bg-[#4b79f6] after:transition-all after:duration-500 hover:after:w-full">Главная</a>
                <a href="tasks.html" class="flex flex-col after:w-0 after:h-[2px] after:rounded-full after:bg-[#4b79f6] after:transition-all after:duration-500 hover:after:w-full">Задания</a>
                <a href="program.html" class="flex flex-col after:w-0 after:h-[2px] after:rounded-full after:bg-[#4b79f6] after:transition-all after:duration-500 hover:after:w-full">Программа обучения</a>
            </div>
            <button id="toggler" class="md:hidden cursor-pointer">
                <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
                    <g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g>
                    <g id="SVGRepo_iconCarrier">
                        <path d="M4 6H20M4 12H14M4 18H9" stroke="#4b79f6" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round"></path>
                    </g>
                </svg>
            </button>
        </div>
    </header>
    <div id="overlay" class="inset-0 fixed bg-black/30 top-0 z-[2] hidden md:hidden"></div>

    <main class="w-full container mx-auto grow flex items-center justify-center my-10 flex-col gap-10 px-4">
        <a href="tasks.html" class="w-fit self-start py-1.5 px-4 rounded-xl bg-[#4B79F6] text-white">Вернуться назад</a>
        <p class="text-3xl text-[#4B79F6] font-medium text-center">Задание 3</p>   
        <div class="relative w-full min-h-[80vh]">
            <div class="main">
                <div id="btn">Вопрос</div>
                <div id="banner">Все вопросы закончились</div>
            </div>
        </div>   
    </main>

    <footer class="w-full bg-white flex flex-col items-center gap-2 text-center p-4 mt-auto">
        <a href="../index.html" class="text-2xl font-semibold transition-all duration-500 hover:rotate-6 hover:scale-110">
            Education<span class="text-[#4b79f6]">Lab</span>
        </a>
        <p class="text-base text-gray-500">© 2025 Education. Все права защищены.</p>
    </footer>

    <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <script src="../Assets/JS/main.js"></script>

    <style>
        /* общий контейнер */
        .main {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60vw;
            min-height: 78vh;
            color: #333333;
            background: linear-gradient(135deg, #f5f7fa, #c3cfe2);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            padding: 20px;
            /* Внутренние отступы */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
    
        /* список вопросов */
        #banner {
            margin: 1vh 0;
            display: none;
            font-size: 2em;
            color: #333333;
            animation: fadeIn 1s ease;
            /* Анимация появления */
        }
    
        /* финальный результат 0/4 */
        #result {
            margin-top: 1vw;
            display: none;
            font-size: 2em;
            color: #333333;
            animation: fadeIn 1s ease;
            /* Анимация появления */
        }
    
        /* кнопка старт */
        #btn {
            margin: 1vw;
            padding: 12px 20px;
            position: relative;
            width: 160px;
            height: 50px;
            text-align: center;
            font-size: 20px;
            background-color: #007bff;
            color: #ffffff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            /* Курсор в виде руки */
            transition: background-color 0.3s ease, transform 0.2s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }
    
        #btn:hover {
            background-color: #007bff;
            transform: scale(1.05);
            /* Увеличение кнопки при наведении */
        }
    
        #btn:active {
            transform: scale(0.95);
        }
    
        /* блок вопросов */
        .question_block {
            margin-top: 2%;
            margin-right: 2%;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            align-items: flex-start;
            position: relative;
            width: 100%;
        }
    
        /* названия вопросов */
        .question {
            width: 100%;
            height: 80px;
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            background-color: #ffffff;
            border-radius: 5px;
            padding: 0 10px;
            animation: question_start 2s forwards;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }
    
        @keyframes question_start {
            0% {
                opacity: 0;
                transform: translate(0, 200px);
            }
    
            50% {
                opacity: 1;
                transform: translate(0, 0);
            }
    
            100% {}
        }
    
        /* номера вопросов 1,2,3,4 */
        .question .index {
            width: 5%;
            text-align: center;
            font-size: 1.5em;
            color: #007bff;
        }
    
        /*  вопросы */
        .question .title {
            flex: 1;
            padding: 0 10px;
            font-size: 1.2em;
            color: #333333;
        }
    
        /* да или нет */
        .question .image_block {
            padding-right: 40px;
            position: relative;
            width: 10%;
        }
    
        /* блок ответов */
        .answer_block {
            margin-top: 2%;
            position: relative;
            width: 100%;
            height: 120px;
            display: flex;
            flex-direction: row;
            justify-content: space-around;
            align-items: center;
            animation: answer_block_start 1.5s forwards;
        }
    
        @keyframes answer_block_start {
            0% {
                opacity: 0;
                transform: translate(-400px, 0);
            }
    
            34% {
                opacity: 0;
                transform: translate(-400px, 0);
            }
    
            100% {
                opacity: 1;
                transform: translate(0, 0);
            }
        }
    
        /* позиции ответов */
        .answer {
            padding: 10px;
            position: relative;
            width: 22%;
            height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            font-size: 16px;
            background-color: #f0f0f0;
            color: #333333;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            /* Плавный переход */
        }
    
        .answer:hover {
            border: 5px solid #007bff;
            transform: scale(1.05);
            /* Увеличение при наведении */
        }
    
        .answer:active {
            transform: scale(0.95);
            /* Уменьшение при нажатии */
        }
    
        /* пояснение */
        .description {
            padding: 10px;
            /* Увеличены внутренние отступы */
            position: relative;
            height: 100px;
            max-width: 71.5%;
            min-width: 71.5%;
            display: none;
            justify-content: center;
            align-items: center;
            background-color: #e0e0e0;
            animation: description_start 1s forwards;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            color: #333333;
        }
    
        @keyframes description_start {
            0% {
                opacity: 0;
                transform: translate(800px, 0);
            }
    
            100% {
                opacity: 1;
                transform: translate(0, 0);
            }
        }
    
        /* все неверные ответы */
        .invalid_answer {
            animation: invalid_answer_out 1s forwards;
        }
    
        @keyframes invalid_answer_out {
            0% {
                opacity: 1;
                transform: translate(0, 0);
            }
    
            100% {
                opacity: 0;
                transform: translate(800px, 0);
            }
        }
    
        /* переменные которые нужно подсчитать для определние позиции */
        :root {
            --shift-left-distance: 0px;
            --shift-top-distance: 0px;
        }
    
        /* используется когда пользователь сделал правильный выбор */
        .valid_answer {
            position: relative;
            animation: valid_answer_left 1s forwards;
        }
    
        @keyframes valid_answer_left {
            0% {
                left: 0;
            }
    
            99% {
                left: var(--shift-left-distance);
            }
    
            100% {
                left: 0;
            }
        }
    
        @media (max-width: 1300px) {
            .answer_block {
                margin-top: 10px;
                height: auto;
                flex-direction: column;
            }
    
            .answer {
                margin-top: 10px;
                width: 56vw;
                height: 60px;
            }
    
            .valid_answer {
                animation: valid_answer_left_1300 1s forwards;
            }
    
            @keyframes valid_answer_left_1300 {
                0% {
                    top: 0;
                }
    
                99% {
                    top: var(--shift-top-distance);
                }
    
                100% {
                    top: 0;
                }
            }
    
            .description {
                max-width: 56vw;
                min-width: 56vw;
                margin-top: 10px;
                position: relative;
            }
        }
    
        /* Анимация появления */
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
    
            to {
                opacity: 1;
            }
        }
    </style>

    <script>

        // Исходный массив
        const que = [
            [
                "А когда с человеком может произойти дрожемент?",
                "Когда он влюбляется",
                "Когда он идет шопиться",
                "Когда он слышит смешную шутку",
                "Когда он боится, пугается",
                "Лексема «дрожемент» имплицирует состояние крайнего " +
                "напряжения и страха: «У меня всегда дрожемент в ногах, когда копы подходят».",
                null, // Выбранный ответ
                4 // Правильный ответ
            ],
            [
                "Говорят, Антон заовнил всех. Это еще как понимать?",
                "Как так, заовнил? Ну и хамло. Кто с ним теперь дружить-то будет?",
                "Антон очень надоедливый и въедливый человек, всех задолбал",
                "Молодец, Антон, всех победил!",
                "Нет ничего плохого в том, что Антон тщательно выбирает себе друзей",
                "Термин «заовнить» заимствован из английского языка, он происходит от " +
                "слова own и переводится как «победить», «завладеть», «получить».",
                null,
                3
            ],
            [
                "А фразу «заскамить мамонта» как понимать?",
                "Разозлить кого-то из родителей",
                "Увлекаться археологией",
                "Развести недотепу на деньги",
                "Оскорбить пожилого человека",
                "Заскамить мамонта — значит обмануть или развести на деньги. " +
                "Почему мамонта? Потому что мошенники часто выбирают в жертвы пожилых " +
                "людей (древних, как мамонты), которых легко обвести вокруг пальца.",
                null,
                3
            ],
            [
                "Кто такие бефефе?",
                "Вши?",
                "Милые котики, такие милые, что бефефе",
                "Лучшие друзья",
                "Люди, которые не держат слово",
                "Бефефе — это лучшие друзья. Этакая аббревиатура от " +
                "английского выражения best friends forever.",
                null,
                3
            ],
        ]


        // Перемешиваем массив
        shuffleArray(que)


        const maxQuestions = que.length;
        const answersCount = 4;

        let currentQuestion = 0;
        let isStarted = false;
        let endedTest = false




        // Перемешивает массив с вопросами
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const randomIndex = Math.floor(Math.random() * (i + 1));
                [array[i], array[randomIndex]] = [array[randomIndex], array[i]];
            }
        }


        document.getElementById("btn")
            .onclick = async function () {
                if (currentQuestion === 0 && !isStarted) {
                    await CreateNextQuestionBlock();
                    isStarted = true;
                }
            }


        // Выбор варианта ответа
        const MakeChose = async (element_index) => {

            // Перестраховка, чтобы не перезаписывалось значение
            if (que[currentQuestion][6] != null)
                return

            que[currentQuestion][6] = element_index

            // Если выбран верный ответ
            if (element_index === que[currentQuestion][7]) {
                SetSuccessMarker();
                await CleanErrorAnswers();
                ShowDescription();

                // Пауза, чтобы прочитать описание
                await delay(3000)

                HideAnswerBlock()
            } else {
                SetErrorMarker();
                await CleanAllAnswers();
                HideAnswerBlock()
            }

            currentQuestion++;

            if (currentQuestion < maxQuestions) {
                await CreateNextQuestionBlock();
            } else {
                endedTest = true;
                document.getElementById("banner")
                    .style.display = "flex"

                let result = 0
                for (let i = 0; i < que.length; i++) {
                    if (que[i][6] == que[i][7]) {
                        result += 1;
                    }
                }

                const resultBlock = document.createElement('div');
                resultBlock.textContent = 'Ваш результат: ' + result + '/' + maxQuestions;
                resultBlock.style.display = 'flex'
                resultBlock.id = 'result'

                document.getElementsByClassName("main")[0]
                    .appendChild(resultBlock);
            }
        }


        // Если ответили верно, нужно убрать неверные ответы, а верный пометить
        const CleanErrorAnswers = async () => {

            let lateDisplayNone = []

            for (let i = 0; i < answersCount; i++) {

                let answer =
                    document.getElementsByClassName("answer" + (i + 1))[currentQuestion]

                // Если текущий вариант ответа не верный
                if (i !== que[currentQuestion][7] - 1) {
                    answer.classList.add("invalid_answer")

                    lateDisplayNone.push(answer)
                } else {
                    // Для адаптивности. Если ширина разрешения > 1300 записываем
                    // в css переменную горизонтальную величину для анимации
                    if (window.innerWidth > 1300) {
                        let width = answer.getBoundingClientRect().width
                        let gup = (((58 / 100) * window.innerWidth) - (width * 4)) / 5;

                        document.documentElement.style.
                            setProperty('--shift-left-distance',
                                "-" + ((width * i) + (gup * i)) + "px");
                    }
                    else {
                        let height = 60
                        let gup = 10;

                        document.documentElement.style.
                            setProperty('--shift-top-distance',
                                "-" + ((height * i) + (gup * i)) + "px");
                    }

                    answer.classList.add("valid_answer")
                }
            }

            await delay(1000)

            for (let i = 0; i < lateDisplayNone.length; i++) {
                lateDisplayNone[i].style.display = "none";
            }
        }


        // Вызывается если ответили неправильно и нужно выкинуть все ответы
        const CleanAllAnswers = async () => {
            // Массив, все элементы которого будут выключены
            let lateDisplayNone = []

            for (let i = 0; i < answersCount; i++) {
                let answer =
                    document.getElementsByClassName("answer" + (i + 1))[currentQuestion]

                answer.classList.add("invalid_answer")
                lateDisplayNone.push(answer)
            }

            await delay(1000)

            for (let i = 0; i < lateDisplayNone.length; i++) {
                lateDisplayNone[i].style.display = "none";
            }
        }


        // Отобразить и скрыть описание
        const ShowDescription = () => {
            document.getElementsByClassName("description")[currentQuestion]
                .style.display = "flex";
        }
        const HideDescription = () => {
            document.getElementsByClassName("description")[currentQuestion]
                .display = "none";
        }


        // Скрывает блок ответов
        const HideAnswerBlock = () => {
            document.getElementsByClassName("answer_block")[currentQuestion]
                .style.display = "none";
        }


        // Отобразить скрытый блок с правильным ответом и описанием
        const ShowAnswerBlock = (index) => {
            //que[index][7]) - это индекс верного ответа для конкретного вопроса
            document.getElementsByClassName("answer" + (que[index][7]))[index]
                .style.position = "relative";
            document.getElementsByClassName("answer" + (que[index][7]))[index]
                .classList.remove("invalid_answer");
            document.getElementsByClassName("answer" + (que[index][7]))[index]
                .style.display = "flex";
            document.getElementsByClassName("answer_block")[index]
                .style.display = "flex";
            document.getElementsByClassName("description")[index]
                .style.display = "flex";
        }


        // Установка картинки(да/нет) в тексте вопроса
        const SetErrorMarker = () => {
            document.getElementsByClassName("image")[currentQuestion]
                .src = "../Assets/Images/tasks/no.png"
        }
        const SetSuccessMarker = () => {
            document.getElementsByClassName("image")[currentQuestion]
                .src = "../Assets/Images/tasks/yes.png"
        }


        // Создание следующего вопроса в тесте
        const CreateNextQuestionBlock = async () => {

            // Чтобы не выйти за пределы массива
            if (currentQuestion > maxQuestions)
                return


            // Создаем блок вопроса с нужной структурой
            const question = `
            <div class="question_block">
                <div class="question">
                    <div class="index">${currentQuestion + 1}.</div>
                    <div class="title">${que[currentQuestion][0]}</div>
                    <div class="image_block">
                        <img class="image" src="">
                    </div>
                </div>
                <div class="answer_block">
                    <div class="answer1 answer">${que[currentQuestion][1]}</div>
                    <div class="answer2 answer">${que[currentQuestion][2]}</div>
                    <div class="answer3 answer">${que[currentQuestion][3]}</div>
                    <div class="answer4 answer">${que[currentQuestion][4]}</div>
                    <div class="description">${que[currentQuestion][5]}</div>
                </div>
            </div>
        `;


            // Добавляем в конце класса main html объект question
            document.getElementsByClassName("main")[0]
                .insertAdjacentHTML('beforeend', question);


            // Добавляю обработчикки для вариантов ответа
            document.getElementsByClassName("answer1")[currentQuestion]
                .onclick = async function () {
                    // this.style.padding = "0 20px"; Не стал делать, не красиво
                    await MakeChose(1)
                };

            document.getElementsByClassName("answer2")[currentQuestion]
                .onclick = async function () {
                    await MakeChose(2)
                };

            document.getElementsByClassName("answer3")[currentQuestion]
                .onclick = async function () {
                    await MakeChose(3)
                };

            document.getElementsByClassName("answer4")[currentQuestion]
                .onclick = async function () {
                    await MakeChose(4)
                };


            // Добавляет обработчики нажатия на блоки вопросов, запоминая их индекс,
            // чтобы потом выдвинуть для него ответ при нажатии
            document.getElementsByClassName("question_block")[currentQuestion]
                .onclick = (function (questionIndex) {
                    return function () {
                        if (endedTest) {
                            ShowAnswerBlock(questionIndex);
                        }
                    };
                })(currentQuestion);
        };


        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

    </script>
</body>
</html>